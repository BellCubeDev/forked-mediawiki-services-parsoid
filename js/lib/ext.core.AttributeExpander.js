/**
 * Generic attribute expansion handler.
 *
 * @author Gabriel Wicke <gwicke@wikimedia.org>
 */
var $ = require('jquery'),
	request = require('request'),
	events = require('events'),
	qs = require('querystring'),
	Util = require('./mediawiki.Util.js').Util,
	ParserFunctions = require('./ext.core.ParserFunctions.js').ParserFunctions,
	AttributeTransformManager = require('./mediawiki.TokenTransformManager.js')
									.AttributeTransformManager,
	defines = require('./mediawiki.parser.defines.js');


function AttributeExpander ( manager, options ) {
	this.manager = manager;
	this.options = options;
	// XXX: only register for tag tokens?
	manager.addTransform( this.onToken.bind(this), "AttributeExpander:onToken",
			this.rank, 'any' );
}

// constants
AttributeExpander.prototype.rank = 1.11;

/**
 * Token handler
 *
 * Expands target and arguments (both keys and values) and either directly
 * calls or sets up the callback to _expandTemplate, which then fetches and
 * processes the template.
 */
AttributeExpander.prototype.onToken = function ( token, frame, cb ) {
	// console.warn( 'AttributeExpander.onToken: ', JSON.stringify( token ) );
	if ( (token.constructor === TagTk ||
			token.constructor === SelfclosingTagTk) &&
				token.attribs &&
				token.attribs.length ) {
		// clone the token
		token = token.clone();
		var atm = new AttributeTransformManager(
					this.manager,
					{ wrapTemplates: this.options.wrapTemplates },
					this._returnAttributes.bind( this, token, cb )
				);
		cb( { async: true } );
		atm.process(token.attribs);
	} else {
		cb ( { tokens: [token] } );
	}
};

// This method does two different things:
//
// 1. Strips all meta tags
//    (FIXME: should I be selective and only strip mw:Object/* tags?)
// 2. In wrap-template mode, it identifies the meta-object type
//    and returns it.
//
function stripMetaTags(tokens, wrapTemplates) {
	var buf = [],
		wikitext = [],
		metaObjTypes = [],
		inTemplate = false;

	for (var i = 0, l = tokens.length; i < l; i++) {
		var token = tokens[i];
		if ([TagTk, SelfclosingTagTk].indexOf(token.constructor) !== -1) {
			// Strip all meta tags.
 			// SSS FIXME: should I be selective and only strip mw:Object/* tags?
			if (wrapTemplates) {
				// If we are in wrap-template mode, extract info from the meta-tag
				var t = token.getAttribute("typeof");
				var typeMatch = t && t.match(/(mw:Object(?:\/.*)?$)/);
				if (typeMatch) {
					inTemplate = !(typeMatch[1].match(/\/End$/));
					if (inTemplate) {
						metaObjTypes.push(typeMatch[1]);
						wikitext.push(token.dataAttribs.src);
					}
				} else {
					buf.push(token);
				}
			}

			// Dont strip token if it is not a meta-tag
			if (token.name !== "meta") {
				buf.push(token);
			}
		} else {
			// Assumes that non-template tokens are always text.
			// In turn, based on assumption that HTML attribute values
			// cannot contain any HTML (SSS FIXME: Isn't this true?)
			if (!inTemplate) {
				wikitext.push(token);
			}
			buf.push(token);
		}
	}

	return {
		// SSS FIXME: Assumes that either the attr. has only 1 expansion
		// OR all expansions are of the same type.
		// Consider the attr composed of pieces: s1, s2, s3
		// - s1 can be generated by a template
		// - s2 can be plain text
		// - s3 can be generated by an extension.
		// While that might be considered utter madness, there is nothing in
		// the spec right now that prevents this.  In any case, not sure
		// we do require all expandable types to be tracked.
		metaObjType: metaObjTypes[0],
		wikitext: Util.tokensToString(wikitext),
		value: buf
	};
}


/**
 * Callback for attribute expansion in AttributeTransformManager
 */
AttributeExpander.prototype._returnAttributes = function ( token, cb, newAttrs )
{
	this.manager.env.dp( 'AttributeExpander._returnAttributes: ', newAttrs );

	var tokens      = [];
	var metaTokens  = [];
	var oldAttrs    = token.attribs;
	var a, newK, i, l, metaObjType, producerObjType, kv, updatedK;

	// Identify attributes that were generated in full or in part using templates
	// and add appropriate meta tags for them.
	for (i = 0, l = oldAttrs.length; i < l; i++) {
		a    = oldAttrs[i];
		newK = newAttrs[i].k;
		updatedK = null;  // init

		if (newK) {
			var contentType = "objectAttrKey"; // default
			if (a.k.constructor === Array) {
				if ( newK.constructor === String && newK.match( /mw\:maybeContent/ ) ) {
					updatedK = Util.stripMetaTags( 'mw:keyAffected', this.options.wrapTemplates );
					newAttrs.push( new KV( 'mw:keyAffected', newAttrs[i].v ) );
					newK = updatedK.value;
				} else {
					updatedK = Util.stripMetaTags(newK, this.options.wrapTemplates);
					newK = updatedK.value;
					if (newAttrs[i].v === '') {
						// Some templates can return content that should be
						// interpreted as a key-value pair.
						// Ex: {{GetStyle}} can return style='color:red;'
						// and might be used as <div {{GetStyle}}>foo</div> to
						// generate: <div style='color:red;'>foo</div>.
						//
						// To support this, we utilize the following hack.
						// If we got a string of the form "k=v" and our orig-v
						// was empty, then, we split the template content around
						// the '=' and update the 'k' and 'v' to the split values.
						var kArr = Util.tokensToString(newK, true);
						var kStr = (kArr.constructor === String) ? kArr : kArr[0];
						var m    = kStr.match(/([^=]+)=['"]?([^'"]*)['"]?$/);
						if (m) {
							contentType = "objectAttr"; // both key and value
							newK = m[1];
							if (kArr.constructor === String) {
								newAttrs[i].v = m[2];
							} else {
								kArr[0] = m[2];
								newAttrs[i].v = kArr;
							}
						}
					}
					newAttrs[i].k = newK;
				}
			}

			if ( updatedK ) {
				metaObjType = updatedK.metaObjType;
				if (metaObjType) {
					producerObjType = metaObjType;
					metaTokens.push( Util.makeTplAffectedMeta(contentType, newK, updatedK) );
				}
			}

			var isHtmlAttrKey = newK.constructor === String && !newK.match(/^mw:/);

			if ( newK.constructor === String && newK.match( /mw\:maybeContent/ ) ) {
				updatedV = Util.stripMetaTags( newAttrs[i].v , this.options.wrapTemplates );
				kv = new KV( 'mw:valAffected', newAttrs[i].v );
				kv.v.push( Util.makeTplAffectedMeta("objectAttrVal", newAttrs[i].k, updatedV) );
				newAttrs.push( kv );
			} else if (isHtmlAttrKey && a.v.constructor === Array) {
				updatedV = Util.stripMetaTags(newAttrs[i].v, this.options.wrapTemplates);
				newAttrs[i].v = updatedV.value;
				metaObjType = updatedV.metaObjType;
				if (metaObjType) {
					producerObjType = metaObjType;
					metaTokens.push( Util.makeTplAffectedMeta("objectAttrVal", newK, updatedV) );
				}
			}
		}
	}

	// Update attrs
	token.attribs = newAttrs;

	// Update metatoken info
	l = metaTokens.length;
	if (l > 0) {
		var tokenId = token.getAttribute( 'about' );

		if ( !tokenId ) {
			tokenId = '#mwt' + this.manager.env.generateUID();
			token.addAttribute("about", tokenId);
			token.addSpaceSeparatedAttribute("typeof", "mw:ExpandedAttrs/" + producerObjType.substring("mw:Object/".length));
		}

		for (i = 0; i < l; i++) {
			metaTokens[i].addAttribute("about", tokenId);
		}
	}

	tokens = metaTokens;
	tokens.push(token);

	cb( { tokens: tokens } );
};

if (typeof module === "object") {
	module.exports.AttributeExpander = AttributeExpander;
}
